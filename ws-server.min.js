const http = require("http");
const fs = require("fs");
const path = require("path");
const chokidar = require("chokidar");
const { WebSocketServer } = require("ws");
const sqlite3 = require("sqlite3").verbose();

const db = new sqlite3.Database("assets.db", (err) => {
  if (err) console.error("SQLite connection error:", err);
});

const PORT = 443;
const ROOT_DIR = path.join(__dirname, "dealerships");

function setCorsHeaders(res) {
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader(
    "Access-Control-Allow-Methods",
    "GET, POST, PUT, PATCH, DELETE, OPTIONS"
  );
  res.setHeader(
    "Access-Control-Allow-Headers",
    "Content-Type, Authorization, X-Requested-With"
  );
}

const server = http.createServer((req, res) => {
  setCorsHeaders(res);

  if (req.method === "OPTIONS") {
    res.writeHead(204);
    return res.end();
  }

  const urlObj = new URL(req.url, `http://${req.headers.host}`);

  if (urlObj.pathname === "/search" && req.method === "GET") {
    return handleSearchRequest(req, res, urlObj);
  }

  if (urlObj.pathname === "/update-asset-alt" && req.method === "POST") {
    return handleAltUpdate(req, res);
  }

  if (urlObj.pathname === "/replace-file-url" && req.method === "POST") {
    return handleFileUrlReplace(req, res);
  }

  const requestedPath = decodeURIComponent(urlObj.pathname);
  const filePath = path.join(ROOT_DIR, requestedPath);

  fs.stat(filePath, (err, stats) => {
    if (err) {
      res.writeHead(404, { "Content-Type": "text/plain" });
      return res.end("Not Found");
    }
    if (stats.isDirectory()) {
      const indexFile = path.join(filePath, "index.html");
      fs.stat(indexFile, (err2, stats2) => {
        if (!err2 && stats2.isFile()) {
          serveFile(indexFile, res);
        } else {
          res.writeHead(403, { "Content-Type": "text/plain" });
          res.end("Forbidden");
        }
      });
    } else {
      serveFile(filePath, res);
    }
  });
});


function handleSearchRequest(req, res, urlObj) {
  const query = urlObj.searchParams.get("q") || "";
  const pageParam = parseInt(urlObj.searchParams.get("page") || "1", 10);
  const page = pageParam < 1 ? 1 : pageParam;

  const limit = 20;
  const offset = (page - 1) * limit;

  if (!query) {
    res.writeHead(400, { "Content-Type": "application/json" });
    return res.end(JSON.stringify({ error: "Missing query param 'q'." }));
  }

  const words = query.split(/\s+/).filter(Boolean);
  const likeClauses = words.map(() => "url LIKE ?");
  const params = words.map((w) => `%${w}%`);
  // Join all like clauses (for your search terms) AND also exclude ".archive" in the URL
  const whereClause = `${likeClauses.join(
    " AND "
  )} AND url NOT LIKE '%.archive%'`;

  // First get total count
  db.get(
    `SELECT COUNT(*) as count 
       FROM assets 
      WHERE ${whereClause}`,
    params,
    (countErr, countResult) => {
      if (countErr) {
        console.error("SQLite error (count):", countErr);
        res.writeHead(500, { "Content-Type": "application/json" });
        return res.end(JSON.stringify({ error: "Database error." }));
      }
      const totalCount = countResult ? countResult.count : 0;
      const totalPages = Math.ceil(totalCount / limit);

      // Then get the actual rows
      db.all(
        `SELECT url, size, alt
           FROM assets
          WHERE ${whereClause}
          LIMIT ? OFFSET ?`,
        [...params, limit, offset],
        (err, rows) => {
          if (err) {
            console.error("SQLite error (rows):", err);
            res.writeHead(500, { "Content-Type": "application/json" });
            return res.end(JSON.stringify({ error: "Database error." }));
          }
          const responseObj = {
            results: rows || [],
            totalPages,
            currentPage: page,
          };
          res.writeHead(200, { "Content-Type": "application/json" });
          res.end(JSON.stringify(responseObj));
        }
      );
    }
  );
}

function handleAltUpdate(req, res) {
  let bodyData = "";
  req.on("data", (chunk) => {
    bodyData += chunk;
  });
  req.on("end", () => {
    try {
      const { url, alt } = JSON.parse(bodyData);
      if (!url) {
        res.writeHead(400, { "Content-Type": "application/json" });
        return res.end(JSON.stringify({ error: "Missing url." }));
      }

      db.run(
        "UPDATE assets SET alt=? WHERE url=?",
        [alt || "", url],
        function (err) {
          if (err) {
            console.error("SQLite error (update alt):", err);
            res.writeHead(500, { "Content-Type": "application/json" });
            return res.end(
              JSON.stringify({ error: "Failed to update alt in DB." })
            );
          }

          res.writeHead(200, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ success: true }));
        }
      );
    } catch (parseErr) {
      console.error("JSON parse error in /update-asset-alt:", parseErr);
      res.writeHead(400, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error: "Invalid JSON body." }));
    }
  });
}

function escapeReg(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

function handleFileUrlReplace(req, res) {
  let bodyData = "";
  req.on("data", (chunk) => {
    bodyData += chunk;
  });
  req.on("end", () => {
    try {
      const { file, oldUrl, newUrl, alt, type } = JSON.parse(bodyData);
      if (!file || !oldUrl || !newUrl) {
        res.writeHead(400, { "Content-Type": "application/json" });
        return res.end(
          JSON.stringify({
            error: "Missing required fields (file, oldUrl, newUrl).",
          })
        );
      }

      const fullPath = path.join(__dirname, file);

      // Normalize incoming URLs in case they have host prefixes
      let new_url = newUrl
        .replace("https://cdn.dlron.us", "")
        .replace("https://localhost:3000", "");
      let old_url = oldUrl
        .replace("https://localhost:3000", "")
        .replace("https://cdn.dlron.us", "");

      fs.readFile(fullPath, "utf8", (readErr, content) => {
        if (readErr) {
          console.error("Read file error:", readErr);
          res.writeHead(500, { "Content-Type": "application/json" });
          return res.end(JSON.stringify({ error: "Failed to read file." }));
        }

        let updated = content;

        if (type === "img") {
          // Handle <img src="..." alt="...">
          const findImgTagRegex = /<img([^>]*)>/gi;
          updated = updated.replace(findImgTagRegex, (fullMatch, inside) => {
            // If this <img> does not contain the old URL, skip
            if (!inside.includes(old_url)) {
              return fullMatch;
            }

            // Replace src
            let newInside = inside.replace(
              new RegExp(`\\bsrc\\s*=\\s*["']${escapeReg(old_url)}["']`, "i"),
              `src="${new_url}"`
            );

            // Insert or update alt
            const altRegex = /\balt\s*=\s*["'][^"']*["']/i;
            if (altRegex.test(newInside)) {
              newInside = newInside.replace(altRegex, `alt="${alt || ""}"`);
            } else {
              // Insert alt before the closing / or end bracket
              newInside = newInside.replace(
                /\s*\/?\s*$/,
                ` alt="${alt || ""}"$&`
              );
            }

            return `<img${newInside}>`;
          });
        } else if (type === "bg") {
          let changesMade = false;

          /**
           * Weâ€™ll do a single-pass replacement looking for elements that:
           * - Have a style attribute
           * - Contain background-image: url(old_url)
           *
           * We replace old_url => new_url, then also insert/update aria-label.
           */
          if (
            file.toLowerCase().endsWith(".html") ||
            file.toLowerCase().endsWith(".htm")
          ) {
            const bgStyleRegex = new RegExp(
              // Capture the entire tag that has `style="...background-image:...old_url..."`
              `(<[^>]+style="[^"]*background-image:\\s*url\\(\\s*["']?${escapeReg(
                old_url
              )}[^"]*["']?\\s*\\)[^"]*"[^>]*>)`,
              "gi"
            );

            const newUpdated = updated.replace(bgStyleRegex, (fullTag) => {
              changesMade = true;

              // 1) Replace the old_url with new_url inside style=""
              let replacedTag = fullTag.replace(
                new RegExp(escapeReg(old_url), "g"),
                new_url
              );

              // 2) Insert or update aria-label in that same tag
              if (/aria-label\s*=\s*"/i.test(replacedTag)) {
                // Update existing aria-label
                replacedTag = replacedTag.replace(
                  /aria-label\s*=\s*"[^"]*"/i,
                  `aria-label="${alt || ""}"`
                );
              } else {
                // Insert aria-label (just before the closing '>')
                replacedTag = replacedTag.replace(
                  /\s*(\/?>)$/,
                  ` aria-label="${alt || ""}" $1`
                );
              }

              return replacedTag;
            });

            if (changesMade) {
              updated = newUpdated;
            }

            // If we didn't find any matching style in the HTML, try the fallback in a .css file
            if (!changesMade) {
              const cssFile = file.replace(/\.html?$/i, ".css");
              const cssFullPath = path.join(__dirname, cssFile);
              try {
                let cssContent = fs.readFileSync(cssFullPath, "utf8");

                // Replace old_url => new_url in CSS
                const cssBgRegex = new RegExp(
                  `url\\(\\s*["']?(${escapeReg(
                    old_url
                  )})(\\?[^"']*)?["']?\\s*\\)`,
                  "gi"
                );
                let matchCount = 0;
                let cssUpdated = cssContent.replace(
                  cssBgRegex,
                  (m, basePart, queryPart) => {
                    matchCount++;
                    return `url("${new_url}${queryPart || ""}")`;
                  }
                );

                if (matchCount > 0) {
                  fs.writeFileSync(cssFullPath, cssUpdated, "utf8");
                  changesMade = true;
                  console.log("[BG] Fallback update in CSS =>", cssFile);
                }
              } catch (cssErr) {
                console.error(
                  "[BG] Could not read/write fallback CSS:",
                  cssErr
                );
              }
            }
          } else if (file.toLowerCase().endsWith(".css")) {
            // Directly in a .css file
            const cssBgRegex = new RegExp(
              `url\\(\\s*["']?(${escapeReg(old_url)})(\\?[^"']*)?["']?\\s*\\)`,
              "gi"
            );

            let matchCount = 0;
            let newUpdated = updated.replace(
              cssBgRegex,
              (m, basePart, queryPart) => {
                matchCount++;
                return `url("${new_url}${queryPart || ""}")`;
              }
            );

            if (matchCount > 0) {
              changesMade = true;
              updated = newUpdated;
            }
          }
        }

        // Finally, write the updated content if we made changes (or for images).
        fs.writeFile(fullPath, updated, "utf8", (writeErr) => {
          if (writeErr) {
            console.error("Write file error:", writeErr);
            res.writeHead(500, { "Content-Type": "application/json" });
            return res.end(JSON.stringify({ error: "Failed to write file." }));
          }
          res.writeHead(200, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ success: true }));
        });
      });
    } catch (parseErr) {
      console.error("JSON parse error in /replace-file-url:", parseErr);
      res.writeHead(400, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error: "Invalid JSON body." }));
    }
  });
}

function serveFile(filePath, res) {
  const ext = path.extname(filePath).toLowerCase();
  let contentType = "application/octet-stream";
  if (ext === ".html" || ext === ".htm") contentType = "text/html";
  else if (ext === ".css") contentType = "text/css";
  else if (ext === ".js") contentType = "application/javascript";
  else if (ext === ".jpg" || ext === ".jpeg") contentType = "image/jpeg";
  else if (ext === ".png") contentType = "image/png";
  else if (ext === ".gif") contentType = "image/gif";

  if (contentType.startsWith("image/") || ext === ".pdf" || ext === ".zip") {
    fs.readFile(filePath, (err, data) => {
      if (err) {
        res.writeHead(500);
        return res.end("Server Error");
      }
      res.writeHead(200, { "Content-Type": contentType });
      res.end(data);
    });
  } else {
    fs.readFile(filePath, "utf8", (err, data) => {
      if (err) {
        res.writeHead(500);
        return res.end("Server Error");
      }
      res.writeHead(200, { "Content-Type": contentType });
      res.end(data, "utf8");
    });
  }
}

function escapeReg(str) {
  return str.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
}

const wss = new WebSocketServer({ noServer: true });
const allClients = new Set();

wss.on("connection", (ws) => {
  allClients.add(ws);
  ws.on("close", () => {
    allClients.delete(ws);
  });
});

server.on("upgrade", (req, socket, head) => {
  wss.handleUpgrade(req, socket, head, (client) => {
    wss.emit("connection", client, req);
  });
});

server.listen(PORT, "0.0.0.0", () => {
  console.log(`Local server running on port ${PORT}`);
});

const watcher = chokidar.watch("dealerships", {
  persistent: true,
  ignoreInitial: true,
});

watcher.on("change", (changedPath) => {
  const msg = JSON.stringify({ type: "file-changed", path: changedPath });
  for (const client of allClients) {
    try {
      client.send(msg);
    } catch (err) {
      console.error("WS send error:", err);
    }
  }
});
